<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Telewizja Online - Moje Kanały</title>
    <!-- Ładowanie Tailwind CSS dla responsywności i estetyki -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Ustawienie czcionki Inter -->
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
        }
    </style>
    <!-- Ładowanie biblioteki HLS.js, niezbędnej do odtwarzania strumieni HLS (m3u8) -->
    <script src="https://cdn.jsdelivr.net/npm/hls.js@1"></script>
</head>
<body class="min-h-screen p-4 sm:p-8">

    <div class="max-w-7xl mx-auto bg-white shadow-xl rounded-xl p-4 sm:p-6 lg:p-8">

        <header class="mb-6 border-b pb-4">
            <h1 class="text-3xl font-bold text-gray-800">Telewizja Online</h1>
            <p class="text-gray-500">Wybierz kanał z listy, aby rozpocząć odtwarzanie.</p>
        </header>

        <main class="grid grid-cols-1 lg:grid-cols-3 gap-6">

            <!-- Sekcja Odtwarzacza Wideo (Lewa i Środkowa kolumna) -->
            <div class="lg:col-span-2">
                <div class="bg-gray-900 rounded-lg overflow-hidden shadow-2xl relative">
                    <!-- Element wideo, do którego hls.js będzie ładować strumień. Usunięto atrybut 'autoplay'. -->
                    <video id="videoPlayer" controls class="w-full aspect-video"></video>
                    <!-- Etykieta aktualnie odtwarzanego kanału -->
                    <div id="currentChannelName" class="absolute top-0 left-0 m-3 px-3 py-1 bg-black bg-opacity-70 text-white font-semibold rounded-full text-sm">
                        Wybierz kanał
                    </div>
                </div>

                <!-- Komunikat statusu/błędu -->
                <div id="statusMessage" class="mt-4 p-3 bg-blue-100 text-blue-800 border border-blue-200 rounded-md hidden">
                    Ładowanie listy kanałów...
                </div>
            </div>

            <!-- Sekcja Listy Kanałów (Prawa kolumna) -->
            <div class="lg:col-span-1 bg-gray-50 p-4 rounded-lg shadow-inner max-h-[80vh] overflow-y-auto">
                <h2 class="text-xl font-semibold mb-3 text-gray-700">Lista Kanałów</h2>
                <div id="channelList" class="space-y-2">
                    <!-- Kanały zostaną wstrzyknięte tutaj przez JavaScript -->
                    <p class="text-gray-400 text-sm">Pobieranie danych...</p>
                </div>
            </div>

        </main>
    </div>

    <script>
        // === KONFIGURACJA ===
        const M3U_URL = 'https://raw.githubusercontent.com/magnus544x/magnus544x/main/playlist.m3u';
        const videoElement = document.getElementById('videoPlayer');
        const channelListElement = document.getElementById('channelList');
        const statusMessageElement = document.getElementById('statusMessage');
        const currentChannelNameElement = document.getElementById('currentChannelName');
        let hls = null; // Zmienna globalna dla instancji HLS

        /**
         * Funkcja pomocnicza do wyświetlania wiadomości statusu.
         * @param {string} message - Treść wiadomości.
         * @param {string} type - Typ wiadomości ('info', 'error', 'success').
         */
        function showStatus(message, type = 'info') {
            statusMessageElement.textContent = message;
            statusMessageElement.classList.remove('hidden', 'bg-blue-100', 'bg-red-100', 'text-blue-800', 'text-red-800');
            statusMessageElement.classList.add('block');

            if (type === 'error') {
                statusMessageElement.classList.add('bg-red-100', 'text-red-800', 'border-red-200');
            } else {
                statusMessageElement.classList.add('bg-blue-100', 'text-blue-800', 'border-blue-200');
            }
        }

        /**
         * Parsuje zawartość pliku M3U i zwraca listę obiektów kanałów.
         * M3U jest prostym formatem tekstowym. Struktura wygląda tak:
         * #EXTINF:-1 tvg-id="ID" tvg-name="NAZWA",NAZWA KANAŁU
         * http://adres-strumienia.m3u8
         *
         * @param {string} m3uContent - Surowa zawartość pliku M3U.
         * @returns {Array<Object>} Lista kanałów (name, url).
         */
        function parseM3U(m3uContent) {
            const lines = m3uContent.split('\n');
            const channels = [];
            let currentChannel = {};

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();

                if (line.startsWith('#EXTINF')) {
                    // Wyciągnięcie nazwy kanału
                    const nameMatch = line.match(/,(.+)$/);
                    currentChannel.name = nameMatch ? nameMatch[1].trim() : 'Nieznany Kanał';

                    // Opcjonalne wyciągnięcie 'tvg-logo'
                    const logoMatch = line.match(/tvg-logo="([^"]+)"/);
                    currentChannel.logo = logoMatch ? logoMatch[1] : null;

                } else if (line.startsWith('http') || line.startsWith('https')) {
                    // Następna linia to URL strumienia
                    currentChannel.url = line;
                    channels.push(currentChannel);
                    currentChannel = {}; // Reset dla kolejnego kanału
                }
            }
            return channels;
        }

        /**
         * Renderuje listę kanałów jako przyciski w bocznym panelu.
         * @param {Array<Object>} channels - Lista kanałów.
         */
        function renderChannels(channels) {
            channelListElement.innerHTML = '';
            if (channels.length === 0) {
                channelListElement.innerHTML = '<p class="text-red-500">Nie znaleziono żadnych kanałów w playliście.</p>';
                return;
            }

            channels.forEach(channel => {
                const button = document.createElement('button');
                button.className = 'w-full text-left p-3 bg-white hover:bg-indigo-50 border border-gray-200 rounded-lg transition duration-200 shadow-sm flex items-center space-x-3 focus:outline-none focus:ring-2 focus:ring-indigo-500';
                button.innerHTML = `
                    ${channel.logo ? `<img src="${channel.logo}" alt="${channel.name} Logo" class="h-6 w-6 object-contain rounded-sm" onerror="this.onerror=null;this.src='https://placehold.co/24x24/cccccc/333333?text=?';">` : `<span class="h-6 w-6 flex items-center justify-center bg-indigo-200 text-indigo-700 rounded-sm font-bold text-xs">${channel.name[0]}</span>`}
                    <span class="text-sm font-medium text-gray-700 truncate">${channel.name}</span>
                `;
                button.onclick = () => playChannel(channel.url, channel.name);
                channelListElement.appendChild(button);
            });
        }

        /**
         * Ładuje i odtwarza strumień wideo dla wybranego kanału.
         * Wykorzystuje bibliotekę HLS.js.
         * @param {string} url - URL strumienia wideo.
         * @param {string} name - Nazwa kanału.
         */
        function playChannel(url, name) {
            // Zatrzymaj poprzednią instancję hls, jeśli istnieje
            if (hls) {
                hls.destroy();
            }

            // Ustaw nazwę aktualnego kanału
            currentChannelNameElement.textContent = name;
            
            // Ukryj komunikat o statusie po rozpoczęciu ładowania
            statusMessageElement.classList.add('hidden');
            
            // Sprawdzenie, czy przeglądarka obsługuje hls.js (jeśli jest potrzebny)
            if (Hls.isSupported()) {
                hls = new Hls();
                hls.attachMedia(videoElement);

                hls.on(Hls.Events.MEDIA_ATTACHED, function () {
                    hls.loadSource(url);
                });

                // POPRAWKA: Dodanie opóźnienia i sprawdzenie, czy wideo jest w pauzie, aby uniknąć race condition
                hls.on(Hls.Events.MANIFEST_PARSED, function () {
                    // Ustawienie krótkiego opóźnienia, aby dać przeglądarce czas na ustabilizowanie stanu
                    setTimeout(() => {
                        if (videoElement.paused) { // Odtwarzaj tylko, jeśli wideo jest faktycznie zatrzymane
                            videoElement.play().catch(error => {
                                console.error("Błąd odtwarzania (autoplay zablokowany lub inny): ", error);
                                showStatus('Przeglądarka zablokowała automatyczne odtwarzanie. Kliknij w obszar odtwarzacza, aby rozpocząć.', 'error');
                            });
                        }
                    }, 50); // Opóźnienie 50 milisekund
                });


                hls.on(Hls.Events.ERROR, function (event, data) {
                    if (data.fatal) {
                        showStatus(`Błąd krytyczny HLS: Nie można odtworzyć strumienia. Spróbuj innego kanału. Szczegóły: ${data.details}`, 'error');
                        switch (data.type) {
                            case Hls.ErrorTypes.NETWORK_ERROR:
                                hls.startLoad();
                                break;
                            case Hls.ErrorTypes.MEDIA_ERROR:
                            case Hls.ErrorTypes.OTHER_ERROR:
                                hls.destroy();
                                break;
                            default:
                                hls.destroy();
                                break;
                        }
                    }
                });

            } else if (videoElement.canPlayType('application/vnd.apple.mpegurl')) {
                // Natywne wsparcie dla HLS (głównie Safari)
                videoElement.src = url;
                // Tutaj też dodajemy małe opóźnienie dla pewności
                setTimeout(() => {
                    if (videoElement.paused) {
                        videoElement.play().catch(error => {
                            console.error("Błąd odtwarzania natywnego (autoplay zablokowany): ", error);
                            showStatus('Przeglądarka zablokowała automatyczne odtwarzanie. Kliknij w obszar odtwarzacza, aby rozpocząć.', 'error');
                        });
                    }
                }, 50);

            } else {
                showStatus('Twoja przeglądarka nie obsługuje odtwarzania HLS.', 'error');
            }
        }

        /**
         * Główna funkcja: pobiera i przetwarza listę odtwarzania.
         */
        async function fetchAndParsePlaylist() {
            showStatus('Pobieranie listy kanałów z GitHub...');
            try {
                const response = await fetch(M3U_URL);
                if (!response.ok) {
                    throw new Error(`Błąd HTTP: ${response.status}`);
                }
                const m3uContent = await response.text();
                const channels = parseM3U(m3uContent);

                if (channels.length > 0) {
                    renderChannels(channels);
                    showStatus(`Pomyślnie załadowano ${channels.length} kanałów. Wybierz kanał do odtworzenia.`, 'success');
                    // Ukryj wiadomość po sukcesie
                    statusMessageElement.classList.add('hidden');
                } else {
                    showStatus('Nie udało się znaleźć żadnych kanałów w pliku M3U. Sprawdź format pliku.', 'error');
                }

            } catch (error) {
                console.error("Błąd ładowania playlisty:", error);
                showStatus(`Nie udało się załadować listy kanałów. Sprawdź, czy URL jest poprawny lub czy plik istnieje. (${error.message})`, 'error');
            }
        }

        // Uruchomienie aplikacji po załadowaniu DOM
        document.addEventListener('DOMContentLoaded', fetchAndParsePlaylist);
    </script>
</body>
</html>
